---
layout: post
title: CH1. 자료구조와 알고리즘의 이해
category: data_structure
tags: [data structure, 자료구조]
comments: true
---

# CH1. 자료구조와 알고리즘의 이해

## 1-1 자료구조에 대한 기본적인 이해
### 자료구조란 무엇인가
- 자료구조에서는 데이터를 표현하고 저장하는 방법에 대해서 설명함
  - 데이터의 저장을 담당하는것이 바로 자료구조
  - 넓은 의미에서 int형 변수 선언이나 구조체의 정의, 배열의 선언 또한 자료구조에 속함
- 실제로는 아래의 세부 자료 구조들이 존재
  - 선형구조
    - 리스트
    - 스택
    - 큐
  - 비선형구조
    - 트리
    - 그래프
  - 파일구조
    - 순차파일
    - 색인파일
    - 직접파일
  - 단순구조
    - 정수
    - 실수
    - 문자
    - 문자열
- 수업에서는 __선형구조, 비선형구조__에 대해서만 다룸
- 선형구조는 자료의 표현방식이 선형임을 의미
  - 선형 자료구조는 데이터를 선의 형태로 나란히 혹은 일렬로 저장하는 방식(공부하기 수월)
- 비선형구조는 데이터를 나란히 저장하지 않음(어려움)

### 본서에서 자료구조 설명하는 방향
- 본 서는 코드레벨에서의 구현이 아닌 __자료구조의 모델 자체에 대한 이해를 강조한 서적__

### 자료구조와 알고리즘
- 자료구조는 데이터의 표현 및 저장방법을 뜻한다면, 알고리즘은 저장된 데이터를 대상으로 하는 문제 해결 방법을 의미
- 따라서 자료구조가 결정되어야 그에 맞는 문제 해결 방법을 제시 할 수 있으므로 밀접한 관계를 가짐

## 1-2 알고리즘의 성능분석 방법

### 시간 복잡도와 공간 복잡도
- 시간 복잡도는 속도에 해당하는 알고리즘의 수행시간 분석결과를 가리킴
- 공간 복잡도는 메모리 사용량에 대한 분석결과를 가리킴
- 보통 공간 복잡도보다 시간 복잡도를 더 중요시 여김
- 시간 복잡도의 판단은 처리해야 할 데이터의 수 $n$에 대한 연산횟수의 함수 $T(n)$을 구성
  - 데이터 수의 증가에 따른 연산횟수의 변화 정도를 정량적으로 판단 할 수 있기 때문

###순차 탐색(Linear search) 알고리즘과 시간 복잡도 분석의 핵심요소
- 순차 탐색 알고리즘이라는 간단한 알고리즘으로 시간 복잡도를 계산
```c
# pragma warning disable(4996)
# include<stdio.h>
int LSearch(int ar[], int len, int target)
{
	int i;
	for (i = 0; i < len; i++)
	{
		if (ar[i] == target)
			return i;
	}
	return -1;
}

int main(void)
{
	int arr[] = { 3, 5, 2, 4, 9 };
	int idx;

	idx = LSearch(arr, sizeof(arr) / sizeof(int), 4);
	if (idx == -1)
		printf("탐색실패 \n");
	else
		printf("타겟 저장 인덱스: %d \n", idx);
	idx = LSearch(arr, sizeof(arr) / sizeof(int), 7);
	if (idx == -1)
		printf("탐색실패 \n");
	else
		printf("타겟 저장 인덱스: %d \n", idx);
	getchar();
	return 0;
}
```
- 위 코드에서 순차탐색 알고리즘인 `LSearch` 함수 내의 for문을 볼 때, 데이터 수 $n$에 대한 시간 복잡도 $T(n)$을 계산해보자.
  - 알고리즘에 사용된 연산자는 <, ++, == 세 가지임
  - __이 중 값을 비교하는 == 연산을 가장 적게 수행하는 탐색 알고리즘이 좋은 탐색 알고리즘임__
  - 즉, 탐색 알고리즘의 핵심은 동등비교를 하는 비교연산에 있음
    - 비교연산을 적게할수록 <연산과 ++연산의 수행횟수가 줄게 됨(__다른 연산들이 == 연산에 의존적__)
  - 즉, ==연산의 횟수를 대상으로 시간 복잡도를 분석하면 됨
  - 찾고자 하는 배열의 값이 맨 앞에 있으면 비교연산의 수행횟수는 1이 됨 -> best case
  - 찾고자 하는 배열의 값이 맨 뒤에 있으면 비교연산의 수행횟수는 n이 됨 -> worst case (__중요__)
  - Average case의 경우 합리적이나 계산이 복잡하고 평균의 정의가 애매 -> 따라서 worst case로 계산

### 순차 탐색 알고리즘의 시간 복잡도 계산 1: Worst case
- 데이터의 수가 n개일때 worst case는 n이 됨
- $T(n)=n$

### 순차 탐색 알고리즘의 시간 복잡도 계산 2: Average case
- 가정 1. 탐색 대상이 배열에 존재하지 않을 확률을 50%라고 가정: $T(n)=n$
- 가정 2. 배열의 첫 요소부터 마지막 요소까지 탐색 대상이 존재할 확률은 동일: $T(n)=\frac{n}{2}$
- 가정 1과 가정 2에 따라 위의 두 식을 하나로 묶어야 함 -> $n\times \frac{1}{2}\times +\frac{n}{2}\frac{1}{2}=\frac{3}{4}n$
- 따라서 순차 탐색 알고리즘의 average case의 시간 복잡도는 $T(n)=\frac{3}{4}n$가 됨
- 계산이 복잡하고, 모든 가정을 제대로 정의하지 못하면 신뢰도가 낮게 됨



  
