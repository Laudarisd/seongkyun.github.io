---
layout: post
title: 알고리즘 기초-브루트 포스
category: algorithm
tags: [algorithm]
comments: true
---

# 알고리즘 기초-브루트 포스
- 문제에 나와있는 모든 경우의 수를 시험해보는 방법.
- 생각보다 적용 가능한 범위가 넓다.
- 예를 들어 4자리 비밀번호를 찾는 경우,
  - 각 자리마다 0~9의 10가지 경우의 수가 있으므로 $10^4$ 번만 시도하면 됨

- 브루트 포스 문제를 풀기 위해선 다음과 같은 3가지 단계를 생각 해 볼수 있음
  - 1. 문제의 가능한 경우의 수를 계산해보고
    - 직접 계산을 통해 구함. 대부분 손으로 계산 가능
  - 2. 가능한 모든 방법을 다 만들어 본 후
    - 하나도 빠짐 없이 만들어야 함
    - 대표적으로 그냥 다 해보는 방법, for문 사용, 순열 사용, 재귀 호출 사용, 비트마스크 사용이 있음
  - 3. 각각의 방법을 이용해 답을 구한다.
    - 이 단계는 어렵지않게 나와있는 대로 답을 계산하면 됨
- 모든 경우의 수를 계산해보고, 가능한 방법을 만들어보는게 중요함
  - 그 중 __2번. 가능한 모든 방법을 다 만들어 보는 것__ 이 가장 중요함
- 일반적으로 브루트 포스에서는 2, 3단계의 시간복잡도가 가장 높음
  - O(경우의 수 \* 방법 1개를 시도하는데 걸리는 시간 복잡도)

- 그냥 다 해보기, for문 사용, 순열 사용, 재귀 호출 사용, 비트마스크 사용 모두 따로 다뤄짐

## 그냥 다 해보기
### 백준 2309
- 왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다. 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다.
- 아홉 명의 난쟁이는 모두 자신이 "백설 공주와 일곱 난쟁이"의 주인공이라고 주장했다. 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.
- 아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오.

- 아홉 난쟁이 중 7명의 키를 더해 100이 되어야 하므로, 전체 9명 중 2명을 뽑고, 전체 키 합 - 100 만큼 둘의 키가 되어야 함
  - sum - 100 = x

- 정렬이 필요한데, 삽입정렬을 사용함
  - 그나마 간단하고 빠름
- 경우의 수가 얼마 안되므로 브루트포스 그냥 해보는게 가능

```c
#pragma warning(disable:4996)
#include<iostream>
#include<stdio.h>
using namespace std;
int main()
{
	int h[9];
	int sum = 0;
	int idx_a, idx_b;
	for (int j = 0; j < 9; j++)
	{
		scanf("%d", &h[j]);
		sum += h[j];
	}

	// sorting (insertion sort)
	for (int j = 1; j < 9; j++)
	{
		int i = j - 1;
		int key = h[j];
		while ((h[i] > key)&(i >= 0))
		{
			h[i + 1] = h[i];
			i = i - 1;
		}
		h[i + 1] = key;
	}
	
	for (int j = 0; j < 9; j++)
	{
		for (int i = j + 1; i < 9; i++)
		{
			if ((h[j] + h[i]) == sum - 100) // 두 난쟁이 키를 더해서 sum-100 조건을 만족하면 원래 7난쟁이가 아님
			{
				idx_a = h[j];
				idx_b = h[i];
			}
		}
	}
	for (int j = 0; j < 9; j++)
	{
		if ((h[j]!=idx_a) & (h[j]!=idx_b))
			printf("%d\n", h[j]);
	}
	return 0;
}
```

### 백준 1476
- 지구를 나타내는 수를 E, 태양을 나타내는 수를 S, 달을 나타내는 수를 M이라고 했을 때, 이 세 수는 서로 다른 범위를 가진다. (1 ≤ E ≤ 15, 1 ≤ S ≤ 28, 1 ≤ M ≤ 19)
- 우리가 알고있는 1년은 준규가 살고있는 나라에서는 1 1 1로 나타낼 수 있다. 1년이 지날 때마다, 세 수는 모두 1씩 증가한다. 만약, 어떤 수가 범위를 넘어가는 경우에는 1이 된다.
- 예를 들어, 15년은 15 15 15로 나타낼 수 있다. 하지만, 1년이 지나서 16년이 되면 16 16 16이 아니라 1 16 16이 된다. 이유는 1 ≤ E ≤ 15 라서 범위를 넘어가기 때문이다.
- E, S, M이 주어졌고, 1년이 준규가 사는 나라에서 1 1 1일때, 준규가 사는 나라에서 E S M이 우리가 알고 있는 연도로 몇 년인지 구하는 프로그램을 작성하시오.

- 최대 가능한 경우의 수를 계산해 보면
  - E는 최대 15가지의 수
  - S는 최대 28가지의 수
  - M은 최대 19가지의 수
  - 총 15 \* 28 \* 19 = 7980 가지의 수밖에 되지 않으므로 시도 가능하다.
- 어렵게 할 것 없이, e, s, m에서 각각 1을 빼면 아래의 조건을 만족하는 장 작은 자연수 year를 찾는 문제가 됨
  - year % 15 == E
  - year % 28 == S
  - year % 19 == M
- 위 조건을 만족하도록 year를 1부터 증가시키면 됨

```c
#pragma warning(disable:4996)
#include<iostream>
#include<stdio.h>
using namespace std;
int main()
{
	int e, s, m;
	scanf("%d %d %d", &e, &s, &m); // e, s, m을 만들고
	e -= 1;
	s -= 1;
	m -= 1;
	for (int i = 0;; i++) // i=0부터 무한대로 계속 발산
	{
		if ((i % 15 == e)&(i % 28 == s)&(i % 19 == m)) // 조건을 만족하면
		{
			printf("%d\n", i + 1); // 출력 후 끝.
			break;
		}
			
	}
	return 0;
}
```

### 백준 14500
- 실수해서 시간 잡아먹기 정말 최고의 문제다.
- 더불어 디버깅 능력이 요구되는 문제이다.
  - 테트리스 모양을 하나 겹치게 파악하는 바람에 디버깅하느라 1시간을 넘게 버렸다..
- 조건은 https://www.acmicpc.net/problem/14500 참조

```c
#pragma warning(disable:4996)
#include<iostream>
#include<stdio.h>
using namespace std;

typedef struct value // 테트리스 블럭의 기본좌표(0,0)에서 초과되는 길이를 반환받기 위한 구조체
{
	int max_x;
	int max_y;
}values;

values max(int arr[][2]) // 테트리스 블럭의 기본좌표에서 초과되는 길이를 반환하는 함수
{
	int max_x = -1;
	int max_y = -1;

	values result;

	for (int j = 0; j < 4; j++)
	{

		if (max_y < arr[j][0])
			max_y = arr[j][0];
		if (max_x < arr[j][1])
			max_x = arr[j][1];
	}
	result.max_x = max_x;
	result.max_y = max_y;
	return result;
}

int main()
{
	int blocks[19][4][2]= // 블럭은 총 19가지의 경우의 수가 존재한다. 조건을 파악할때 실수하지 않도록 조심해야한다..
	{
	{ { 0,0 },{ 0,1 },{ 0,2 },{ 0,3 } }, // 모든 블럭은 좌측 상단이 기준점이며, 해당 좌표에 블럭이 존재하지 않으면 다른 좌표에서 시작
	{ { 0,0 },{ 1,0 },{ 2,0 },{ 3,0 } }, // 임베딩은 왼쪽 위에서 오른쪽 아래로 표현되어있음
	{ { 0,0 },{ 0,1 },{ 1,0 },{ 1,1 } },
	{ { 0,0 },{ 1,0 },{ 2,0 },{ 2,1 } },
	{ { 0,0 },{ 0,1 },{ 1,1 },{ 2,1 } },
	{ { 0,0 },{ 1,0 },{ 1,1 },{ 1,2 } },
	{ { 0,0 },{ 0,1 },{ 0,2 },{ 1,0 } },
	{ { 0,2 },{ 1,0 },{ 1,1 },{ 1,2 } },
	{ { 0,0 },{ 0,1 },{ 0,2 },{ 1,2 } },
	{ { 0,0 },{ 0,1 },{ 1,0 },{ 2,0 } },
	{ { 0,1 },{ 1,1 },{ 2,0 },{ 2,1 } },
	{ { 0,0 },{ 1,0 },{ 1,1 },{ 2,1 } },
	{ { 0,1 },{ 1,0 },{ 1,1 },{ 2,0 } },
	{ { 0,1 },{ 0,2 },{ 1,0 },{ 1,1 } },
	{ { 0,0 },{ 0,1 },{ 1,1 },{ 1,2 } },
	{ { 0,1 },{ 1,0 },{ 1,1 },{ 1,2 } },
	{ { 0,0 },{ 0,1 },{ 0,2 },{ 1,1 } },
	{ { 0,0 },{ 1,0 },{ 1,1 },{ 2,0 } },
	{ { 0,1 },{ 1,0 },{ 1,1 },{ 2,1 } }
	};

	values maxes;

	int bg[500][500]; // 최대 값을 할당하여 background를 만들고
	int n, m;
	scanf("%d %d", &n, &m);
	for (int j = 0; j < n; j++)
	{
		for (int i = 0; i < m; i++)
		{
			scanf("%d", &bg[j][i]); // 사용자에게 입력받아서 2d로 background를 생성
		}
	}
	int max_x, max_y;
	int sums[19];
	int sum, sum_max;
	for (int k = 0; k < 19; k++) // 총 19가지의 모양에 대해
	{
		sum = 0;
		sum_max = 0;

		maxes = max(blocks[k]);
		max_y = maxes.max_y; // x, y 각각 bg를 넘어갈 수 없으므로 초과되는 값을 받아 저장
		max_x = maxes.max_x;
		
		for (int j = 0; j < n - max_y; j++) // bg의 수직방향, 각 블럭이 초과 참조 못하게 초과값(max_x, y) 반영
		{
			for (int i = 0; i < m - max_x; i++) // bg의 수평방향
			{
				sum = 0;
				for (int h = 0; h < 4; h++) // 블럭 내부에 있는 point들로 접근
				{
					sum += bg[j + blocks[k][h][0]][i + blocks[k][h][1]]; // bg에 있는 해당 point의 값을 sum에 더함
				}
				if (sum_max < sum)
					sum_max = sum; // 각 블럭 모양마다 최댓값을 sum_max에 저장하도록
			}
		}
		sums[k] = sum_max; // sums에 각 블럭 모양마다 최댓값이 저장됨 (총 19개 경우의 수)
	}

	int prev = -1;
	for (int j = 0; j < 19; j++)
	{
		if (prev < sums[j])
			prev = sums[j]; // prev에 최댓값을 저장해
	}
	printf("%d\n", prev); // 출력
	return 0;
}
```
