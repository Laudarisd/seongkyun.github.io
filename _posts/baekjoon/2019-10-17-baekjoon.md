---
layout: post
title: 1910177 백준 알고리즘 문제풀기
category: baekjoon
tags: [baekjoon]
comments: true
---

## [15683] 감시
- 난이도: 극상상!
  - 문제 이해하는데는 10분도 걸리지 않았지만, 구현+디버깅하는데 3~4시간이 넘게 소요된듯 하다.
    - 처음에 전체 맵에 대해 모든 경우의 수를 구하도록 했더니 worst case 기분 연산까지 1분이 넘게 소모된다.
  - DFS의 이용에 대해 익숙하지 않아서 이렇게 오래 걸린듯 하다.
  - DFS를 조금 더 응용할 수 있는 능력을 길러야 할 듯 하다.
    - DFS는 모든 경우의 수를 찾을 때(완전탐색) 굉장히 유용한 알고리즘이다.
    - 함수를 재귀적으로 구성하고, 어떤 조건을 만족했을 때 해당 재귀를 끝내고 연산을 시작하게 만들 수 있다.
  - 개인적으로 풀어본 문제 중 가장 공부가 많이 되었던 문제인것 같다.
    - 나중에 복습해야할듯.
  - 특히, 모든 카메라의 경우의 수를 고려할 때 2차원 배열로 해서 각각 위치에 가능한 카메라들을 할당하고 접근하여 풀게 했더니 무조건 시간초과가 나는 결과를 초래했다.
    - Worst case 기준 1분이 넘어가도 경우의 수가 계산되지 않음..
  - 연구소 문제같은 경우는 2차원 배열 안에서 벽을 선택하면 되지만, 이런 문제는 그런식으로 접근하면 무조건 시간초과가 발생한다.
  - __이런식으로 어떠한 큰 배열(Map) 안에 특정 점의 소수의 상태(Camera)가 주어지는 경우, 맵에서 모든 경우의 수를 찾는게 아니라 Camera에서 모든 경우의 수를 찾아야 한다.__
  - 중요한 타입의 문제 같으니 꼭 다시한번 봐야할듯..
  
- 문제
  - https://www.acmicpc.net/problem/15683
  - 입력으로 N, M, N열 M행의 맵의 주어질 때, 카메라의 사각지대가 최소가 될 때의 사각지대 크기를 구한다.
  - 맵이 입력되고, 카메라는 1~5, 벽은 6으로 주어진다.
  - 카메라끼리 보는 영역은 중첩될 수 있다. 단, 카메라는 통과 할 수 있지만 벽은 통과하지 못한다.
  - 카메라는 각각 90도씩 회전 가능하며, 아래 영역을 한번에 본다.
    1. 한 방향
    2. 좌, 우
    3. 상, 우
    4. 좌, 상, 우
    5. 네 방향
  - 모든 경우의 수를 구해 사각지대를 계산한다.

- 풀이
  - 문제를 나누면
    - 입력을 받고
    - 모든 경우의 수를 찾은다음에
    - 찾아진 각 경우의 수에 대해 카메라가 보는 영역을 만들고
    - 사각지대를 계산해서
    - 최솟값을 저장한다.
  - 가장 중요한 부분은 모든 경우의 수를 찾는 부분이다.
    - DFS를 이용해서 모든 경우의 수를 찾는다.
    - 각 카메라는 1, 3, 4는 4가지의 경우의 수, 2는 2가지, 5는 1가지의 경우의 수가 있다.
    - 이에 맞게 각각 최대 경우의 수를 설정하고(각각 숫자는 방향을 의미하도록!)
    - 해당 카메라가 고를 수 있는 방향의 경우의 수 중 방향을 정하고
    - 다음 카메라로 넘어가 또 방향의 경우의 수 중 방향을 정한다.
    - 만약 모든 카메라를 다 정했으면 경우의 수를 구한것이므로 연산을 시작한다.
    - 자세한건 밑에 코드에...
  - 카메라 방향을 정했으면, 카메라가 보는 영역을 만든다.
    - 간단하게 while문으로 카메라의 어떤 방향으로만 참조하는 함수를 만들고 호출해 완성
  - 사각지대를 계산
    - 전체 맵에서 카메라, 벽은 세지 않는다.
    - 이에 근거해 빈 칸(0)을 세면 된다.

```c
#pragma warning(disable:4996)
#include <iostream>
#include <cstdio>
#include <vector>
#include <tuple>

#define MAX 2147483647

using namespace std;

struct camera
{
	int x, y, type;
};

int map[9][9]; // 맵 저장
int chosen_dir[9][9]; // 선택된 방향
int calc_map[9][9]; // 계산용 맵
vector<camera> cams;

int dx[] = { 0, 1,0,-1,0 }; // 1, 2, 3, 4 index는
int dy[] = { 0, 0,1,0,-1 }; // 우, 하, 좌, 상 순서

int num_cams = 0;
int answer = MAX;

void init_calcmap(int h, int w)
{ // 계산용 맵을 초기화한다.
	for (int j = 0; j < h; j++)
	{
		for (int i = 0; i < w; i++)
		{
			calc_map[j][i] = chosen_dir[j][i];
		}
	}
}

void viewer(int h, int w, int nx, int ny, int dir)
{ // 해당 방향으로 끝날때까지 check한다.
	while (1)
	{
		nx += dx[dir];
		ny += dy[dir];
		if (nx < 0 || w <= nx || ny < 0 || h <= ny) break; // 범위 벗어나면 끝
		if (map[ny][nx] == 6) break; // 벽 나오면 끝
		calc_map[ny][nx] = 1;
	}
	return;
}

void view_map(int h, int w, int cx, int cy, int type, int dir)
{ // 카메라의 종류에 따라 맵을 완성시킨다.
	int nx = cx;
	int ny = cy;
	if (type == 1)
	{
		calc_map[cy][cx] = 1; // 현재위치 찍고
		viewer(h, w, nx, ny, dir); // 본다.
	}
	else if (type == 2)
	{// 2번 방향 좌우
		calc_map[cy][cx] = 1; // 현재위치 찍고
		if (dir == 1)
		{// 좌우 1, 3
			viewer(h, w, nx, ny, 1);
			viewer(h, w, nx, ny, 3);
		}
		if (dir == 2)
		{// 상하 4, 2
			viewer(h, w, nx, ny, 4);
			viewer(h, w, nx, ny, 2);
		}
	}
	else if (type == 3)
	{// 3번 방향 상우
		calc_map[cy][cx] = 1; // 현재위치 찍고
		if (dir == 1)
		{// 상우 4, 1
			viewer(h, w, nx, ny, 4);
			viewer(h, w, nx, ny, 1);
		}
		if (dir == 2)
		{// 우하 1, 2
			viewer(h, w, nx, ny, 1);
			viewer(h, w, nx, ny, 2);

		}
		if (dir == 3)
		{// 하좌 2, 3
			viewer(h, w, nx, ny, 2);
			viewer(h, w, nx, ny, 3);
		}
		if (dir == 4)
		{// 좌상 3, 4
			viewer(h, w, nx, ny, 3);
			viewer(h, w, nx, ny, 4);
		}
	}
	else if (type == 4)
	{// 4번 방향 좌상우
		calc_map[cy][cx] = 1; // 현재위치 찍고
		if (dir == 1)
		{// 좌상우 3, 4, 1
			viewer(h, w, nx, ny, 3);
			viewer(h, w, nx, ny, 4);
			viewer(h, w, nx, ny, 1);
		}
		if (dir == 2)
		{// 상우하 4, 1, 2
			viewer(h, w, nx, ny, 4);
			viewer(h, w, nx, ny, 1);
			viewer(h, w, nx, ny, 2);
		}
		if (dir == 3)
		{// 우하좌 1, 2, 3
			viewer(h, w, nx, ny, 1);
			viewer(h, w, nx, ny, 2);
			viewer(h, w, nx, ny, 3);
		}
		if (dir == 4)
		{// 하좌상 2, 3, 4
			viewer(h, w, nx, ny, 2);
			viewer(h, w, nx, ny, 3);
			viewer(h, w, nx, ny, 4);
		}
	}
	else //(type == 5)
	{
		calc_map[cy][cx] = 1; // 현재위치 찍고
		//4방향
		for (int i = 1; i < 5; i++)
		{
			viewer(h, w, nx, ny, i);
		}
	}
	return;
}

void calc(int h, int w)
{
	// 사각지대 만들기
	for (int i = 0; i < num_cams; i++)
	{//카메라들 동안
		int cx = cams[i].x;
		int cy = cams[i].y;
		int type = cams[i].type;
		int cd = chosen_dir[cy][cx];
		view_map(h, w, cx, cy, type, cd); // 현재 카메라가 보는 맵 만들기.
	}

	// 사각지대 세기
	int cnt = 0;
	for (int j = 0; j < h; j++)
	{
		for (int i = 0; i < w; i++)
		{
			if (map[j][i] == 0)
			{//카메라 감시 가능한 구간만
				if (calc_map[j][i] == 0)
				{//사각지대 세기
					cnt++;
				}
			}
		}
	}
	//정답 비교
	if (cnt < answer) answer = cnt;
}

void dfs(int h, int w, int cnt)
{
	if (cnt == num_cams)
	{// 마지막 카메라까지 방향을 골랐으면
		init_calcmap(h, w); // 계산용 맵 초기화하고
		calc(h, w); // 계산을 시작한다.
		return;
	}
	//가능한 카메라 기본 방향은 4방향으로 하고
	int dir_cnt = 4;
	if (map[cams[cnt].y][cams[cnt].x] == 2) dir_cnt = 2; // 2번카메라는 2방향
	if (map[cams[cnt].y][cams[cnt].x] == 5) dir_cnt = 1; // 5번카메라는 1방향
	for (int i = 1; i <= dir_cnt; i++)
	{//모든 카메라 방향동안
		chosen_dir[cams[cnt].y][cams[cnt].x] = i;//현재 순번 카메라 좌표의 방향을 찍고
		dfs(h, w, cnt + 1); //다음 카메라로 넘어간다.
	}

}

int main()
{
	int N, M;
	scanf("%d %d", &N, &M);
	for (int j = 0; j < N; j++)
	{
		for (int i = 0; i < M; i++)
		{
			scanf("%d", &map[j][i]);
			if (map[j][i] != 0 && map[j][i] != 6)
			{//카메라라면
				cams.push_back({ i,j,map[j][i] }); // 카메라들 저장
				//x, y, type, dir
			}
		}
	}
	//카메라 개수 세고
	num_cams = cams.size();
	//경우의 수 만들기 시작
	dfs(N, M, 0);

	//정답
	printf("%d\n", answer);

	//std::system("pause");
	return 0;
}
```
