---
layout: post
title: 191006 백준 알고리즘 문제풀기
category: baekjoon
tags: [baekjoon]
comments: true
---

## [14890번] 경사로
- 난이도: 상
  - 전형적인 시뮬레이션 문제로, 푸는데 2시간정도 소요됐다. 시험에 나왔으면 틀렸다.
    - 문제 풀이 떠올리는데 1시간, 구현에 1시간..
    - 구현은 정말 쉬웠지만, 풀이를 나누고 case 분류하는데 정말 애를 많이 먹엇다.
  - 시뮬레이션 문제의 경우, 한 번에 모두 해결하려면 정말 답도 없다.
    - 문제를 작게 쪼개고, case를 잘 분류해서 하나하나 해결해가야 풀 수 있을 것 같다.
  - 처음에 문제를 보자마자 쉽겠지 하고 무턱 시작했다가 큰 낭패를 봤다.
  - 시뮬레이션 문제를 풀 때는 
    - 우선, 문제를 작게 나누고(가능한 상황으로)
    - 나눠진 문제에 대해 조건을 확인하고
    - 알고리즘으로 구현해야 한다.

- 문제
  - https://www.acmicpc.net/problem/14890
  - NxN 맵과 경사로 길이가 주어질 때, 경사로를 두고 해당 맵을 가로, 세로로 건널 수 있는 경우의 수를 출력한다.
    - 하나의 알고리즘으로 두 개의 회전된 맵을 만들고, 이를 이용해 풀면 된다.

- 풀이
  - 우선, 한 줄의 가로 배열에 대한 풀이만 해결하면 문제를 풀 수 있다.
    - 이를 세로로 쌓고, 가로로 돌려서 적용하는 식으로 전체에 가로/세로 방향의 경우의 수를 모두 따질 수 있음
  - case 분류
    - 다음 칸과 높이가 같은 경우
    - 다음 칸이 높고, 1 차이나는 경우
    - 다음 칸이 낮고, 1 차이나는 경우
    - 외의 경우는 무조건 건널 수 없다(break)
  - __시뮬레이션 문제에서 제일 중요한건 case를 분류하는것이다!__
    - 분류된 case를 토대로 조건에 맞게 완성시켜 나가면 되기 때문

```c
#pragma warning(disable:4996)
#include <iostream>
#include <queue>
#include <tuple>
#include <cmath>
#include <algorithm>

using namespace std;

int map_a[100][100]; // 가로 맵 저장용
int map_b[100][100]; // 세로 맵 저장용

bool flat(int arr[], int s, int d) // 인덱스 s부터 d까지 평평한가(그래야 경사로를 둘 수 잇음)
{ // s: start index, d: dest index
	int cnt = 0;
	for (int i = s; i < d; i++)
	{
		if (arr[i] - arr[i + 1] != 0)
		{
			cnt++;
		}
	}
	if (cnt == 0)
		return true; // 평평하면 true 반환
	else
		return false; // 아니면 false 반환
}

bool stair(int arr[], int s, int d) // s부터 d까지 계단 세울 수 있는가 (계단이 존재하지 않아야 함)
{
	int cnt = 0;
	for (int i = s; i <= d; i++)
	{
		if (arr[i] == 2)
			cnt++;
	}
	if (cnt == 0)
		return true;
	else
		return false;
}


void make_stair(int check[], int s, int d) // 계단을 세운다.
{
	for (int i = s; i <= d; i++)
	{
		check[i] = 2;
	}
}

bool checker(int arr[], int w, int l)
{
	int check[100]; // check 배열엔 지나간 경우는 1, 경사로 세운 경우는 2, 못 지나간 경우는 0으로 표시
	std::fill_n(check, w, 0); // check배열 0으로 초기화

	for (int i = 0; i < w; i++)
	{ // 전체 배열에 대해서
		if (i == w - 1)
		{ // 마지막 인덱스까지 왔다면 앞 인덱스의 조건은 모두 통과한 경우다.
			check[i] = 1; // 따라서 1로 채운다.
			break;
		}
		if (arr[i] == arr[i + 1])
		{//다음칸과 높이가 같은 경우
			if (check[i] == 0) // 만약 현재 위치에 경사로가 존재하지 않는다면
				check[i] = 1; // 지나간다.
			else
				continue; // 경사로가 존재한다면 넘어간다.(경사로 중복 방지)
		}
		else if (arr[i] < arr[i + 1] && arr[i + 1] - arr[i] == 1)
		{//다음칸이 높고 1 차이나는 경우
			int sx = i - l + 1; // 경사로 처음 좌표
			int dx = i; // 경사로 마지막 좌표
			if (0 <= sx && flat(arr, sx, dx) && stair(check, sx, dx))
			{//이전에 길이가 충분하고, 경사로 구간이 평평하며, 경사로 구간에 다른 경사로가 존재하지 않다면
				make_stair(check, sx, dx);//해당 구간 경사로를 만든다.
			}
			else break; // 아니라면 break(뒤 쪽 볼 필요 없음)
		}
		else if (arr[i] > arr[i + 1] && arr[i] - arr[i + 1] == 1)
		{//다음칸이 낮고 1 차이나는 경우
			int sx = i;
			int dx = i + l;
			if (dx < w && flat(arr, sx + 1, dx) && stair(check, sx + 1, dx))
			{//다음에 경사로를 둘 길이가 충분하고, 경사로 구간이 평평하며, 경사로 구간에 다른 경사로가 존재하지 않다면
				check[i] = 1; // 현재 위치를 1로 초기화(지나갔으므로)
				make_stair(check, sx + 1, dx); // 경사로를 둔다.
				i = dx - 1; // index를 경사로 마지막 위치로 초기화한다.(중복으로 for문 돌을 필요 없음)
			}
			else break; // 아니라면 break(뒤쪽 볼 필요 없음)
		}
		else // 아닌 경우 무조건 갈 수 없음
			break;
	}
	
	//갈 수 있는지 check
	bool go = true;
	for (int i = 0; i < w; i++)
	{
		if (check[i] == 0)
			go = false; // 만약 끝까지 못간경우 false반환
	}

	return go;
}

int main()
{
	int N, L;
	scanf("%d %d", &N, &L);
	for (int j = 0; j < N; j++)
	{
		for (int i = 0; i < N; i++)
		{
			scanf("%d", &map_a[j][i]); // 가로 방향 입력
			map_b[i][j] = map_a[j][i]; // 세로 방향 초기화
		}
	}

	int ans = 0;
	for (int j = 0; j < N; j++)
	{
		ans += checker(map_a[j], N, L); // 가로 방향 계산
	}
	for (int j = 0; j < N; j++)
	{
		ans += checker(map_b[j], N, L); // 세로 방향 계산
	}

	printf("%d\n", ans);
	
	//system("pause");
	return 0;
}
```
