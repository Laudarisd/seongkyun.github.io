---
layout: post
title: 선택/삽입/거품/병합/힙/카운팅/기수정렬 알고리즘
category: study
tags: [정렬, sorting]
comments: true
---

# 선택/삽입/거품/병합/힙/카운팅/기수정렬 알고리즘

백준 알고리즘 문제를 풀며 다뤄지는 다양한 방법의 정렬 알고리즘들에 대해 알아보려 한다.

## 선택 정렬 (Selection Sort)
- 이름처럼 현재 위치에 들어갈 값을 찾아 정렬하는 배열
- 현재 위치에 저장될 값의 크기가 작냐, 크냐에 따라 최소 선택 정렬, 최대 선택 정렬로 구분됨
  - 최소 선택 정렬은 오름차순, 최대 선택 정렬은 내림차순
- 알고리즘
  - 정렬 되지 않은 인덱스의 맨 앞부터 이를 포함한 그 이후의 배열값 중 가장 작은 값을 찾아감
    - 정렬되지 않은 인덱스의 맨 앞은 초기 입력에서는 배열의 시작위치가 됨
  - 가장 작은 값을 찾으면 그 값을 현재 인덱스의 값과 바꿔줌
  - 다음 인덱스에서 위 과정을 반복함

<center>
<figure>
<img src="/assets/post_img/study/2019-01-31-sorting/fig1.gif" alt="views">
</figure>
</center>

- 알고리즘은 n-1개, n-2개, ..., 1개를 각각 비교함.
  - 따라서 배역 어떻게 되었던 전체 비교를 진행하므로 시간 복잡도는 $O(n^{2})$
  - 공간 복잡도는 단 하나의 배열에서만 진행하므로 $O(n)$
  
- 코드

```python
def selectionSort(x):
	length = len(x)
	for i in range(length-1):
	    indexMin = i
		for j in range(i+1, length):
			if x[indexMin] > x[j]:
				indexMin = j
		x[i], x[indexMin] = x[indexMin], x[i]
	return x
```

## 삽입 정렬 (Insertion Sort)
- 현재 위치에서 그 이하의 배열들을 비교하여 자신이 들어갈 위치를 찾아 그 위치에 삽입하는 배열 알고리즘
- 알고리즘
  - 두 번째 인덱스부터 비교하며, 현재 인덱스는 별도의 변수에 저장하고 비교 인덱스를 현재 인덱스-1로 잡음
  - 별도 저장해둔 삽읍을 위한 변수와 비교 인덱스의 배열 값 비교
  - 삽입 변수의 값이 더 작으면 현재 인덱스로 비교 인덱스의 값을 저장하고, 비교 인덱스를 01 하여 비교 반복
  - 만약 삽입 변수가 더 크면 비교 인덱스+1에 삽입 변수를 저장

<center>
<figure>
<img src="/assets/post_img/study/2019-01-31-sorting/fig2.PNG" alt="views">
</figure>
</center>

- 최악의 경우(역정렬) n-1, n-2, .., 1개씩 비교하여 시간복잡도는 $O(n^{2})$ 이나, 이미 정렬되어 있는 경우엔 한 번씩밖에 비교를 하지 않아 복잡도는 $O(n)$이 됨
- 공간 복잡도는 단 하나의 배열에서만 진행하므로 $O(n)$

- 코드

```python
def insert_sort(x):
	for i in range(1, len(x)):
		j = i - 1
		key = x[i]
		while x[j] > key and j >= 0:
			x[j+1]  = x[j]
			j = j - 1
		x[j+1] = key
	return x
```

## 거품 정렬 (Bubble Sort)
- 
## 병합
- 
## 힙
- 
## 카운팅
- 
## 기수
- 




---

- [참고글]

https://hsp1116.tistory.com/33
