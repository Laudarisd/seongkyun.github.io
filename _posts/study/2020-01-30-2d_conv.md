---
layout: post
title: 2D convolution methods
category: study
tags: [Convolution, Fast convolution]
comments: true
---

# 2D convolution methods
- 참고
  - https://janth.home.xs4all.nl/Publications/html/conv2d.html

- 가장 간단한것부터 가장 빠른 cache re-usage에 최적화된 방법까지 다뤄짐
- 2D convolution은 4개의 중첩 루프(nested loop)로 생각하면 됨
- 코드 내에서
  - `oplx`, `oply`는 operator의 x와 y방향의 길이
  - `nx`, `ny`는 data 크기
    - spatial 방향의 x, y 길이
  - `opx` 배열은 convolution operator를 담고 있음
  - `data`는 입력 데이터를 담고 있음
  - `velmod`는 new operator가 load 되어야하는지 마는지에 대한 정보를 담는 2d array
    - operator는 convolution의 계수(weight)를 의미함
    - `velmod`가 이전에 사용된 operator(`c`)와 다를 경우 새로운 operator가 load되어야 함
  - `readtable2D`는 `c`와 `om`에 의존적으로 정확한 operator를 load하는 함수임

## 1. Simple method
- 알듯이, for문을 이용해 도는 방법
- Operator에 대해서 대칭을 사용하지 않고 모든 x와 y의 위치를 반복해서 전체 operator의 길이(`oplx` \* `oply` 만큼) convolution을 수행하는 방법
  - 아래 코드는 경계부분 처리를 위한 방법을 포함하고 있음
- Simple method는 symmetry 특성을 전혀 사용하지 않음

<center>
<figure>
<img src="/assets/post_img/study/2020-01-30-2d_conv/fig1.gif" alt="views">
<figcaption></figcaption>
</figure>
</center>

```c
hoplx = (oplx + 1) / 2;
hoply = (oply + 1) / 2;

for(iy = 0; iy < ny; iy++)
{
  starty = MAX(iy - hoply + 1, 0);
  endy = MIN(iy + hoply, ny);
  for(ix = 0; ix < nx; ix++)
  {
    startx = MAX(ix - hoplx + 1, 0);
    endx = MIN(ix + hoplx, nx);
    /*if velocity changes, then calculate new operator*/
    if(velmod[iy*nx + ix] != c)
    {
      c = velmod[iy*nx+ix];
      readtable2D(opx, om/c, hoplx, hoply, mode);
    }
    
    /* convolution with the operator */
    dumr = dumi = 0.0;
    k = MAX(hoply-1-iy, 0);
    for (i = starty; i < endy; i++)
    {
      l = MAX(hoplx-1-ix, 0);
      for (j = startx; j < endx; j++)
      {
        dumr += data[i*nx+j].r*opx[k*oplx+l].r;
        dumr += data[i*nx+j].i*opx[k*oplx+l].i;
        dumi += data[i*nx+j].i*opx[k*oplx+l].r;
        dumi -= data[i*nx+j].r*opx[k*oplx+l].i;
        l++;
      }
      k++;
    }
    convr[iy*nx+ix].r = dumr;
    convr[iy*nx+ix].i = dumi;
  }
}
```

