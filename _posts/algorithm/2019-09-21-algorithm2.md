---
layout: post
title: 알고리즘 기초-비트마스크
category: algorithm
tags: [algorithm]
comments: true
---

# 알고리즘 기초-비트마스크
- 비트 연산을 사용해 부분집합을 표현 할 수 있음
- 비트 연산은 일반적인 연산과 동일
  - &(and), \|(or), ~(not), ^(xor)

## 두 수의 연산
- A와 B를 비트 연산 시 가장 뒤 자리부터 하나씩 수행
  - 자릿수가 다른 두 2진수의 비트 연산은 앞에 0을 넣어 자릿수를 같게 한 후 계산하면 됨
- A = 11011(2), B = 1010011(2) 일 때 (각각 A=27, B=83)
- A&B = 19, A\|B = 91, A^B = 72

- Not 연산의 경우 자료형에 따라 결과가 달라짐
  - 컴퓨터구조, 디지털공학등에서 배웠던 unsigned/signed 기억하면 될듯..
    - unsigned는 맨 앞까지 모두 양수로 표현
    - signed는 맨 앞 1비트(MSB)는 최대 음수, 뒤쪽 모두 더해서 계산..
  - 자료형이 어떤거(int, long 등)이냐에 따라 또 Not 값이 달라짐

- Left/right 시프팅 연산 (<< ,  >>)
  - 각각 2로 곱해주고, 나눠주는 역할
- 하지만 critical 한 속도 향상은 없음

## 정수로 집합을 나타내기
- {1, 3, 4, 5, 9} = 570으로, 각 인덱스 별 2진수의 승수로 계산됨
  - $570 = 2^1+2^3+2^4+2^5+2^9$
- 공간적인 의미에서 굉장히 효과적입
- 배열 내에 다른 배열을 할당하는 식으로도 관리가 가능하다.
  - 즉, 여러가지 경우의 수가 있는 경우, 이를 활용하면 N 차원의 배열을 1자리 숫자로 표현 가능
  - ex. {{1, 3, 4, 5, 9}, {{1, 3, 4, 5, 9}}, {1, 3, 4, 5, 9}} 의 2차원 배열은 {570, 570, 570}의 1차원 배열로 표현 가능

## 원소의 검사
- __S & (1<<i)__ 를 하면, i가 S에 포함되어있는지 검사 가능함
  - 그 결과가 0이 아니라면 S에는 i가 포함되어있음


