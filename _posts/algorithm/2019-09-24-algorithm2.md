---
layout: post
title: 알고리즘 기초-덱 사용하기
category: algorithm
tags: [algorithm]
comments: true
---

# 알고리즘 기초-덱 사용하기
- 덱은 양방향 큐
  - 양방향에서 데이터를 넣고/꺼내고 할 수 있음
- BFS 문제에서 덱을 사용하면 편리한 경우가 많음
- BFS에선 거리가 1 차이나는 것만 사용 가능했음
  - 모든 문제에서, 거리가 1(시간 등) 차이 나는 경우를 고려해 BFS 알고리즘으로 문제 해결
  - 2 차이나는건 큐 기반의 BFS로 풀이 불가능
    - 큐에 들어있는 거리가 1 차이나야만 구조상 적용 가능했음
- 덱 기반의 BFS는 가중치 거리 0인 경우에도 한번에 적용 가능
  - 기존의 큐 기반의 BFS는 1초, 0초인 경우 두 개의 큐를 만들어 풀어야 했음

### 13549 숨바꼭질 3
- https://www.acmicpc.net/problem/13549
- 수빈이 위치 N
- 동생의 위치 K
- N에서 K로 가는 가장 빠른 위치 구하기
  - 순간이동 2\*N: 0초
  - 이동 +1, -1: 1초
- ex. 5~17 가는 경우
  - 0~20초까지만 있다고 가정

<center>
<figure>
<img src="/assets/post_img/algorithm/2019-09-24-algorithm/fig5.PNG" alt="views">
<img src="/assets/post_img/algorithm/2019-09-24-algorithm/fig6.PNG" alt="views">
<img src="/assets/post_img/algorithm/2019-09-24-algorithm/fig7.PNG" alt="views">
<figcaption> </figcaption>
</figure>
</center>

- 40초는 범위를 벗어나기때문에 고려하지 않아도 됨

- 이 경우, 다시 2초 큐를 만들고, 1초 큐가 기존의 0초 큐 자리를 대체
  - 여기서 5초의 경우 이미 방문했으므로 pass

<center>
<figure>
<img src="/assets/post_img/algorithm/2019-09-24-algorithm/fig8.PNG" alt="views">
<img src="/assets/post_img/algorithm/2019-09-24-algorithm/fig9.PNG" alt="views">
<figcaption> </figcaption>
</figure>
</center>

- 이런식으로 진행 됨

```c
#pragma warning(disable:4996)
#include <iostream>
#include <tuple>
#include <queue>
#include <cstring>
using namespace std;

const int MAX = 100000 * 2;
bool check[MAX];
int times[MAX];

int main()
{
	int N, M;
	scanf("%d %d", &N, &M);
	
	queue<int> cur; // 0초 시간용 큐
	queue<int> next; // 1초 시간용 큐
	
	check[N] = true; // 현재 큐를 방문
	times[N] = 0; // 그 때의 소요 시간
	cur.push(N);
	
	while (!cur.empty())
	{
		int now = cur.front(); // 현재의 위치 초기화
		cur.pop();
		if (now * 2 < MAX && check[now * 2] == false) // 순간이동시
		{
			cur.push(now * 2); // 현재 시간 기준으로 이동
			check[now * 2] = true;
			times[now * 2] = times[now]; // 시간은 더해지지 않음
		}
		if (now - 1 >= 0 && check[now - 1] == false) // 뒤로 가는 경우
		{
			next.push(now - 1); // 뒤로 가기
			check[now - 1] = true;
			times[now - 1] = times[now] + 1; // 시간 더해짐
		}
		if (now + 1 < MAX && check[now + 1] == false) // 앞으로 가는 경우
		{
			next.push(now + 1); // 앞으로 가기
			check[now + 1] = true;
			times[now + 1] = times[now] + 1; // 시간 더해짐
		}
		if (cur.empty()) // 현재 시점에서 만족하는 조건이 없으면
		{
			cur = next; // 시간을 뒤로 넘기기
			next = queue<int>(); // 다음 큐 다시 설정
		}
	}

	printf("%d\n", times[M]);


	//system("pause");
	return 0;
}
```

- 덱 풀이 소스

```c
#pragma warning(disable:4996)
#include <iostream>
#include <queue>
#include <deque>
using namespace std;
const int MAX = 100000 * 2;
bool check[MAX];
int times[MAX];

int main()
{
	int N, M;
	cin >> N >> M;
	check[N] = true;
	times[N] = 0;
	deque<int> q;
	q.push_back(N);
	while (!q.empty())
	{
		int now = q.front();
		q.pop_front();
		if (now * 2 < MAX && check[now * 2] == false)
		{
			q.push_front(now * 2); // 0초인 것은 앞에서 push
			check[now * 2] = true;
			times[now * 2] = times[now];
		
		}
		if (now - 1 >= 0 && check[now - 1] == false)
		{
			q.push_back(now - 1); // 1초인 것은 뒤에서 push
			check[now - 1] = true;
			times[now - 1] = times[now] + 1;

		}
		if (now + 1 < MAX && check[now + 1] == false)
		{
			q.push_back(now + 1);
			check[now + 1] = true;
			times[now + 1] = times[now] + 1;
		}
	}
	cout << times[M] << '\n';

	system("pause");
	return 0;
}
```
